import random

class Team:
    def __init__(self, r):
        self.r = r

    def __repr__(self):
        return "{}".format(self.r)

def game(a, b):
    d = (0. + b.r - a.r)/400.0
    outcome = random.random() < (1./(1. + 10**d))
    return [a,b] if outcome else [b,a]

def bo3(a, b):
    # return a_wins, b_wins, winner, loser
    a_wins, b_wins = 0, 0
    while a_wins < 2 and b_wins < 2:
        if game(a, b)[0] == a:
            a_wins += 1
        else:
            b_wins += 1            
    return [a_wins, b_wins, a if a_wins > b_wins else b, a if a_wins < b_wins else b]

class Metric:
    def __init__(self):
        self.correct = 0 # all ties are right
        self.incorrect = 0 # at least one tie broken is wrong

        self.unweighted_correct = 0
        self.count = 0

    @property
    def accuracy(self):        
        if self.total:
            return (100. * self.correct) / self.total
        else:
            return None

    @property
    def unweighted(self):
        if self.count:
            return (100. * self.unweighted_correct) / self.count
        else:
            return None

    @property
    def total(self):
        return self.correct + self.incorrect

    def add(self, r):
        fully, partial, right, wrong = r[0], r[1], r[2], r[3]

        if not partial:
            pass
        else:
            self.unweighted_correct += right
            self.count += (right + wrong)
            
            if wrong == 0:
                self.correct += 1
            else:
                self.incorrect += 1

    def __repr__(self):
        return "{:.3f} (n={}, unweighted={:.3f})".format(self.accuracy, self.total, self.unweighted)
   
def eval_tb(d):
    # takes in a dictionary of ratings -> a 'score' generated by the tiebreaker
    # higher is implied to be better, tiebreakers can shift that around if needed
    items = d.items()
    unique = set(d.values())
    fully, partial = len(unique) == len(items), len(unique) > 1
    right, wrong = 0, 0
    if not partial:
        return (False, False, 0, 0)
    
    for i in items:
        for j in items:
            if i[0] > j[0] and i[1] < j[1]:
                wrong += 1
            else:
                right += 1    
    return (fully, partial, right, wrong)

def simulate(N, debug=True, num_teams=8, delta=100):
    # model params
    teams = [Team(s) for s in range(1000, 1000 + (num_teams * delta), delta)]

    # factorial precalculating
    fac_cache = {}
    val = 1
    for i in range(1, 1 + num_teams):
        val *= i
        fac_cache[i] = val 
        
    # track the performance of various tiebreakers
    metrics = {
        'series_neustadtl': Metric(),
        'game_wins': Metric(),
        'game_diff': Metric(),
        '2-0s': Metric(),
        'series_h2h': Metric(), # win difference among tied teams
        'games_h2h': Metric() # games won among tied teams
        }


    for n in range(N):
        series_wins = {}
        games_won = {}
        game_difference = {}
        twooh = {}
        results = []
        for _ in teams:
            series_wins[_.r] = 0
            games_won[_.r] = 0
            game_difference[_.r] = 0
            twooh[_.r] = 0
        
        for a in teams:
            for b in teams:
                if (a.r < b.r):
                    result = bo3(a,b)        
                    results.append(result)
                    series_wins[result[2].r] += 1
                    games_won[a.r] += result[0]
                    games_won[b.r] += result[1]
                    game_difference[a.r] += result[0] - result[1]
                    game_difference[b.r] += result[1] - result[0]
                    if result[0] == 0:
                        twooh[result[2].r] += 1

        if debug:
            for k, v in sorted(series_wins.items(), key=lambda x: -x[1]):
                print("{} -> {} (Games Won: {} / Game Diff: {}, 2-0s: {}) ".format(
                    v, k, games_won[k], game_difference[k], twooh[k]))

        for score in range(1 + max(series_wins.values())):
            matched = [sw[0] for sw in series_wins.items() if sw[1] == score] # all teams tied on this score
            if len(matched) > 1: # roll out the tiebreakers              
                if debug: print(score, matched)
                
                # calculate both neutstadtls for tied teams
                series_neustadtl = {} 
                for _ in matched:
                    series_neustadtl[_] = 0
                for _ in results:
                    if _[2].r in matched:
                        series_neustadtl[_[2].r] = series_wins[_[3].r] + series_neustadtl[_[2].r]

                # calculate h2h
                series_h2h = {}
                games_h2h = {}
                for _ in matched:
                    series_h2h[_] = 0
                    games_h2h[_] = 0                    
                for _ in results:
                    if _[2].r in matched and _[3].r in matched: # both winner and loser are involved
                        series_h2h[_[2].r] = 1 + series_h2h[_[2].r]
                        series_h2h[_[3].r] = -1 + series_h2h[_[3].r]

                        games_h2h[_[2].r] = max(_[0], _[1]) - min(_[0], _[1]) + games_h2h[_[2].r] # increase winners game diff
                        games_h2h[_[3].r] = min(_[0], _[1]) - max(_[0], _[1]) + games_h2h[_[3].r] # increase losers games diff
                
                metrics['series_neustadtl'].add(eval_tb(series_neustadtl))
                metrics['game_wins'].add(eval_tb({r: games_won[r] for r in matched}))
                metrics['2-0s'].add(eval_tb({r: twooh[r] for r in matched}))
                metrics['series_h2h'].add(eval_tb({r: series_h2h[r] for r in matched}))
                metrics['games_h2h'].add(eval_tb({r: games_h2h[r] for r in matched}))
                metrics['game_diff'].add(eval_tb({r: game_difference[r] for r in matched}))
    return metrics
                
if __name__ == '__main__':
    met = simulate(10**5, debug=False)

    for name, m in sorted(met.items(), key=lambda x: -x[1].accuracy):
                print("{}: {}".format(name, m))    
        

